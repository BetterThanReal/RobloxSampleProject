<roblox version="4">
  <Item class="HttpService" referent="0">
    <Properties>
      <string name="Name">HttpService</string>
      <bool name="HttpEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="Lighting" referent="1">
    <Properties>
      <string name="Name">Lighting</string>
      <Color3 name="Ambient">
        <R>0</R>
        <G>0</G>
        <B>0</B>
      </Color3>
      <float name="Brightness">2</float>
      <bool name="GlobalShadows">true</bool>
      <bool name="Outlines">false</bool>
      <token name="Technology">1</token>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="2">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="3">
      <Properties>
        <string name="Name">Assets</string>
      </Properties>
      <Item class="Folder" referent="4">
        <Properties>
          <string name="Name">Game</string>
        </Properties>
        <Item class="RemoteEvent" referent="5">
          <Properties>
            <string name="Name">ClientServerEvent</string>
            <BinaryString name="AttributesSerialize">
            </BinaryString>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags">
            </BinaryString>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="6">
      <Properties>
        <string name="Name">Scripts</string>
      </Properties>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">Game</string>
          <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> shared/Game/init"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'Game' })

local imports = {
  ClientServerEvent = Require.instance('/shared/Assets/Game/ClientServerEvent'),
  Game = Require.module('/runEnv/Game'),
  GameStateStore = Require.module('/runEnv/Game/GameState/Store'),
  RoduxRemoteBridge = Require.module('/shared/Helpers/RoduxRemoteBridge'),
}

function initializeStore()
  local log = logger
  if log then
    log:info("Initializing game Rodux store")
  end

  local event = imports.ClientServerEvent

  local remoteDispatcher =
    imports.RoduxRemoteBridge.withDispatchToRemote(event)

  local store = imports.GameStateStore.create(remoteDispatcher)

  imports.RoduxRemoteBridge.relayDispatchesFromRemote(event, store)
  return store
end

-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.start()
  imports.Game.initRunEnv(initializeStore)
end

print "[LOAD] &lt;- shared/Game/init"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
        </Properties>
        <Item class="ModuleScript" referent="8">
          <Properties>
            <string name="Name">Bootstrap</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(config)
print "[LOAD] -> shared/Game/Bootstrap"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local function getAssert()
  return function(test, message, level, ...)
    if (test == false or test == nil) then
      level = level or 1
      warn("\n", debug.traceback())
      if type(message) == 'function' then
        message = message(...)
      end
      error(message, 2 + (level - 1))
    end
  end
end

local function getRequire(config, global)
  config = config or {}

  local defaults = config.defaults or {}
  local waitTimeout =
    defaults.waitTimeout and tonumber(defaults.waitTimeout) or 10

  return require(
    game:GetService('ReplicatedStorage')
      :WaitForChild('Scripts', waitTimeout)
      :WaitForChild('Helpers', waitTimeout)
      :WaitForChild('Require', waitTimeout)
    )(global, {
      mapping = {
        client = ':StarterPlayer/StarterPlayerScripts/Scripts',
        runEnv = '/' .. global.runEnv,
        shared = ':ReplicatedStorage/Scripts',
        server = ':ServerScriptService/Scripts',
        ['shared/Assets'] = ':ReplicatedStorage/Assets',
      }
    })
end

local isClient = game:GetService("RunService"):IsClient()
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local global = {
  Assert = getAssert(),
  game = game,
  isClient = isClient,
  runEnv = isClient and 'client' or 'server',
}

global.Require = getRequire(config, global)
global.Require.module('/shared/Game').start()

print "[LOAD] &lt;- shared/Game/Bootstrap"
return global
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="9">
          <Properties>
            <string name="Name">RemoteActions</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> shared/Game/RemoteActions"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local moduleName = 'RemoteActions'
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'RemoteActions' })
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local typeBalanceUpdated = moduleName .. ":" .. "balanceUpdated"
local typeWagerConcluded = moduleName .. ":" .. 'wagerConcluded'
local typeWagerRequested = moduleName .. ":" .. 'wagerRequested'

module.ACTION_TYPE = {
  balanceUpdated = typeBalanceUpdated,
  wagerConcluded = typeWagerConcluded,
  wagerRequested = typeWagerRequested,
}

function module.balanceUpdated(player, balance)
  return {
    type = typeBalanceUpdated,
    player = player,
    balance = balance,
  }
end

function module.wagerConcluded(player, wagerAmount, earnings)
  return {
    type = typeWagerConcluded,
    player = player,
    earnings = earnings,
    wagerAmount = wagerAmount,
  }
end

function module.wagerRequested(player, wagerAmount)
  return {
    type = typeWagerRequested,
    player = player,
    wagerAmount = wagerAmount,
  }
end

print "[LOAD] &lt;- shared/Game/RemoteActions"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="10">
        <Properties>
          <string name="Name">Helpers</string>
        </Properties>
        <Item class="ModuleScript" referent="11">
          <Properties>
            <string name="Name">Logger</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> shared/Helpers/Logger"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert

local ERR_INVALID_SELF = "Class method was invoked as a function"

local LOG_LEVEL = {
  NONE = 0,
  FATAL = 1,
  CRITICAL = 2,
  ERROR = 3,
  WARN = 4,
  INFO = 5,
  VERBOSE = 6,
  DEBUG = 7,
}

local PREFIX = {
  [LOG_LEVEL.FATAL] = 'FATAL',
  [LOG_LEVEL.CRITICAL] = 'CRITICAL',
  [LOG_LEVEL.ERROR] = 'ERROR',
  [LOG_LEVEL.WARN] = 'WARN',
  [LOG_LEVEL.INFO] = 'INFO',
  [LOG_LEVEL.VERBOSE] = 'INFO+',
  [LOG_LEVEL.DEBUG] = 'DEBUG',
}

local fnNoOp = function() end

local function getDefaultLogLevel()
  local defaults = global.defaults or {}
  local level = defaults.logLevel

  if type(level) == 'string' then
    level = LOG_LEVEL[string.upper(level)]
  end

  return level or LOG_LEVEL.ERROR
end

local function getLogLevel(level)
  if type(level) == 'string' then
    level = LOG_LEVEL[string.upper(level)]
  end
  return level
end

local function defaultLogFn(level, isWarn, ...)
  if isWarn then
    warn(...)
  else
    print(...)
  end
end

local function getPrefixForLevel(level, isWarn)
  local prefix = PREFIX[level]

  if isWarn and level ~= LOG_LEVEL.WARN then
    prefix = prefix .. "(WARN)"
  end

  return prefix or ""
end

local function log(self, msgLevel, isWarn, ...)
  local triggerLevel = not isWarn and self.level or
    math.max(self.level, self.warnLevel)

  msgLevel = msgLevel == nil and LOG_LEVEL.NONE or
    math.min(msgLevel, LOG_LEVEL.DEBUG)

  if msgLevel &lt;= LOG_LEVEL.NONE or msgLevel > triggerLevel then
    return
  end

  local name = self.name and ("{" .. self.name .. "}: ") or ""
  local prefix = "[" .. getPrefixForLevel(msgLevel, isWarn) .. "] "

  self.logFn(msgLevel, isWarn, prefix .. name, ...)
end
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- CLASS DEFINITION [BEGIN] --------------------------------------------------
local class = {
  NONE = LOG_LEVEL.NONE,
  FATAL = LOG_LEVEL.FATAL,
  CRITICAL = LOG_LEVEL.CRITICAL,
  ERROR = LOG_LEVEL.ERROR,
  INFO = LOG_LEVEL.INFO,
  VERBOSE = LOG_LEVEL.VERBOSE,
  DEBUG = LOG_LEVEL.DEBUG,
}

function isClass(self)
  return self and self._class and self._class == class or false
end

function class.getNullLogger()
  return {
    fatal = fnNoOp,
    critical = fnNoOp,
    error = fnNoOp,
    warn = fnNoOp,
    info = fnNoOp,
    verbose = fnNoOp,
    debug = fnNoOp,
  }
end

function class:critical(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.CRITICAL, true, ...)
end

function class:debug(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.DEBUG, false, ...)
end

function class:error(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.ERROR, true, ...)
end

function class:fatal(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.FATAL, true, ...)
end

function class:info(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.INFO, false, ...)
end

function class:verbose(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.VERBOSE, false, ...)
end

function class:warn(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.WARN, true, ...)
end

function class:warnDebug(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.DEBUG, true, ...)
end

function class:warnInfo(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.INFO, true, ...)
end

function class:warnVerbose(...)
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  log(self, LOG_LEVEL.VERBOSE, true, ...)
end

function class:new(config)
  Assert(self == class, ERR_INVALID_SELF, 2)

  local obj = { _class = class }
  setmetatable(obj, self)
  self.__index = self

  config = config or {}
  obj.level = getLogLevel(config.level) or getDefaultLogLevel()
  obj.warnLevel = getLogLevel(config.warnLevel) or obj.level
  obj.logFn = config.logFn or defaultLogFn
  obj.name = config.name
  return obj
end

print "[LOAD] &lt;- shared/Helpers/Logger"
return class
-- CLASS DEFINITION [END] ----------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="12">
          <Properties>
            <string name="Name">Reducer</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> shared/Helpers/Reducer"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'Reducer' })

local imports = {
  TableHelper = Require.module('/shared/Helpers/TableHelper'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.create(initialState, handlers)
  Assert(initialState, "Initial state for reducer was not provided")
  Assert(handlers, "Handler function table for reducer was not provided")

  return function(state, action, ...)
    state = state or initialState
    local handler = handlers[action.type]

    if handler then
      state = handler(state, action, ...)
    end

    return state
  end
end

function module.withLogging(logger, reducer)
  return function(state, action, ...)
    if not logger then
      return reducer(state, action)
    end

    logger:debug("State prior to reducer:", state, "with action:", action)
    local _state = reducer(state, action)
    logger:debug("State after reducer:", _state)
    return _state
  end
end

function module.withMergedState(reducer)
  local augment = imports.TableHelper.augment

  return function (state, action, ...)
    return augment({}, reducer(state, action, ...), state)
  end
end

print "[LOAD] &lt;- shared/Helpers/Reducer"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="13">
          <Properties>
            <string name="Name">RemoteListener</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/Helpers/RemoteListener"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local ERR_INVALID_SELF = "Class method was invoked as a function"

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'RemoteListener' })
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- CLASS DEFINITION [BEGIN] --------------------------------------------------
local class = {}

function isClass(self)
  return self and self._class and self._class == class or false
end

function class:connect()
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  self:disconnect()

  local parameters = self.connection.parameters

  local log = logger
  if log then
    log:verbose("Connecting RemoteListener", parameters)
  end

  local event = parameters.event
  local eventFn = parameters.isClient and event.OnClientEvent
    or event.onServerEvent

  self.handler = eventFn:Connect(

    function(...)
      if log then
        log:debug("Calling RemoteListener callback", parameters, ...)
      end

      return parameters.callback(...)
    end)

  return self.handler
end

function class:disconnect()
  Assert(isClass(self), ERR_INVALID_SELF, 2)
  local parameters = self.connection.parameters

  local log = logger
  if log then
    log:verbose("Disconnecting RemoteListener", parameters)
  end

  local event = parameters.event
  local handler = self.connection.handler

  if event and handler then
    local eventFn = parameters.isClient and event.OnClientEvent
      or event.onServerEvent

    eventFn:Disconnect(handler)
    self.connection.handler = nil
  end
end

function class:new(event, callback, name)
  Assert(class == self, ERR_INVALID_SELF, 2)

  local obj = { _class = self }
  setmetatable(obj, self)
  self.__index = self

  obj.connection = {
    handler = nil,
    parameters = {
      callback = callback,
      event = event,
      isClient = global.isClient,
      name = name,
    },
  }
  return obj
end

print "[LOAD] &lt;- client/Game/Helpers/RemoteListener"
return class
-- CLASS DEFINITION [END] ----------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="14">
          <Properties>
            <string name="Name">Require</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global, config)
print "[LOAD] -> shared/Helpers/Require"

global = global or {}
config = config or {}

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local game = global.game
local defaults = global.defaults or {}
local waitTimeout =
  defaults.waitTimeout and tonumber(defaults.waitTimeout) or 10

local STR = string.format

local function ERR_MSG_FN(msg)
  return function(...)
    return STR(msg, ...)
  end
end

local ERR_FN_PARAM_MISSING = ERR_MSG_FN(
  "Required function parameter '%s' was empty or not specified")

local ERR_INVALID_SELF = "Class method was invoked as a function"

local ERR_M_PARAM_MISSING = ERR_MSG_FN(
  "Required method parameter '%s' was empty or not specified")

local instancesByPath = {}
local modulesByPath = {}

-- Thanks to Steve Donovan
-- https://github.com/stevedonovan/Microlight/blob/master/ml.lua#L23
function strSplit(s,re,n)
    local find,sub,append = string.find, string.sub, table.insert
    local i1,ls = 1,{}
    if not re then re = '%s+' end
    if re == '' then return {s} end
    while true do
        local i2,i3 = find(s,re,i1)
        if not i2 then
            local last = sub(s,i1)
            if last ~= '' then append(ls,last) end
            if #ls == 1 and ls[1] == '' then
                return {}
            else
                return ls
            end
        end
        append(ls,sub(s,i1,i2-1))
        if n and #ls == n then
            ls[#ls] = sub(s,i1)
            return ls
        end
        i1 = i3+1
    end
end

local function getCanonicalPath(path)
  if path then
    path = string.gsub(path, "/+", "/")
    local children = strSplit(path, "/")
    if children[1] == "" then
      table.remove(children, 1)
    end
    path = table.concat(children, "/")
    return path, children
  end
end

local function resolveService(serviceName)
  Assert(serviceName, ERR_FN_PARAM_MISSING, 2, 'serviceName')

  if string.sub(serviceName, 1, 1) == ":" then
    serviceName = string.sub(serviceName, 2)
  end

  local service = game:GetService(serviceName)
  Assert(service, STR("Unable to get requested service '%s'", serviceName), 2)

  return service
end

local function resolveInstanceChild(
  instance, instancePath, childName, childPath)

  Assert(instance, ERR_FN_PARAM_MISSING, 2, 'instance')
  Assert(instancePath, ERR_FN_PARAM_MISSING, 2, 'instancePath')
  Assert(childName, ERR_FN_PARAM_MISSING, 2, 'childName')
  Assert(childPath, ERR_FN_PARAM_MISSING, 2, 'childPath')

  local child = instance:WaitForChild(childName, waitTimeout)
  Assert(child, STR, 2,
    "Unable to resolve child '%s' of instance '%s'", childName, instancePath)

  instancesByPath[childPath] = child
  return child
end

local function resolveInstance(path, visited)
  Assert(path, ERR_FN_PARAM_MISSING, 2, 'path')

  local paths = nil
  path, paths = getCanonicalPath(path)
  Assert(#paths > 0, ERR_FN_PARAM_MISSING('path'), 2)

  visited = visited or {}
  Assert(not visited[path], STR, 2,
    "Encountered circular dependency resolving instance '%s'", path)

  visited[path] = true

  local instancePath = paths[1]
  local instancePaths = { instancePath }

  for i = 2, #paths do
    instancePath = instancePath .. '/' .. paths[i]
    instancePaths[#instancePaths + 1] = instancePath
  end

  local instance = nil
  local found = nil

  for i = 1, #paths do
    local check = instancesByPath[instancePaths[i]]
    if check then
      instance = check
      found = i
    end
  end

  if type(instance) == 'function' then
    instance = instance()
  end

  if type(instance) == 'string' then
    instance = resolveInstance(instance, visited)
  end

  if string.sub(paths[1], 1, 1) == ":" then
    instance = resolveService(paths[1])
    found = 1
  end

  Assert(instance, STR, 2,
    "Unable to resolve requested path '%s'", path)

  for i = found, #paths - 1 do
    local childName = paths[i + 1]
    local childPath = instancePaths[i + 1]
    instancePath = instancePaths[i]
    instance = resolveInstanceChild(
      instance, instancePath, childName, childPath)

    Assert(instance, STR, 2,
      "Unable to resolve requested path '%s'", instancePath)
  end

  return instance
end

local function requireByPath(path)
  Assert(path, ERR_FN_PARAM_MISSING, 2, 'path')

  local paths = nil
  path, paths = getCanonicalPath(path)
  Assert(#paths > 0, ERR_FN_PARAM_MISSING, 2, 'path')

  if modulesByPath[path] then
    return modulesByPath[path]
  end

  local instance = resolveInstance(path)
  Assert(instance, STR, 2, "Unable to resolve module '%s'", path)

  local status, module = pcall(function() return require(instance) end)
  Assert(status, STR, 2, "Error requiring module '%s': [%s]", path, module)

  if type(module) == 'function' then
    status, module = pcall(function() return module(global) end)
    Assert(status, STR, 2, "Error requiring module function '%s': [%s]", path, module)
  end

  modulesByPath[path] = module
  return module
end

local function mapInstance(path, instance)
  Assert(path, ERR_M_PARAM_MISSING, 2, 'path')
  Assert(instance, ERR_M_PARAM_MISSING, 2, 'instance')

  local paths = nil
  path, paths = getCanonicalPath(path)
  Assert(#paths > 0,
    "A Require mapping contained an empty name", 2)
  Assert(string.sub(paths[1], 1, 1) ~= ":",
    "A Require mapping contained a name that starts with a service", 2)

  if type(instance) == 'string' then
    local instancePaths = nil
    instance, instancePaths = getCanonicalPath(instance)
    Assert(#instancePaths > 0,
      "A Require mapping contained an empty value", 2)
  end

  instancesByPath[path] = instance
end

local function mapInstances(mapping)
  mapping = mapping or {}

  for path, instance in pairs(mapping) do
    mapInstance(path, instance)
  end
end
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.instance(path)
  Assert(path, ERR_M_PARAM_MISSING, 2, 'path')
  return resolveInstance(path)
end

function module.map(path, instance)
  Assert(path, ERR_M_PARAM_MISSING, 2, 'path')
  Assert(instance, ERR_M_PARAM_MISSING, 2, 'instance')
  return mapInstance(path, instance)
end

function module.module(path)
  Assert(path, ERR_M_PARAM_MISSING, 2, 'path')
  return requireByPath(path)
end

function module.service(name)
  Assert(name, ERR_M_PARAM_MISSING, 2, 'name')
  return resolveService(name)
end

do
  mapInstances(config.mapping)
end

print "[LOAD] &lt;- shared/Helpers/Require"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">RoduxEffects</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> shared/Helpers/RoduxEffects"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'RoduxEffects' })

local imports = {
  TableHelper = Require.module('/shared/Helpers/TableHelper'),
}

local function dispatchEffect(store, effect)
  local log = logger

  coroutine.wrap(function()
    if type(effect) == "function" then
      if log then
        log:debug("Dispatching effect:", store:getState())
      end
      effect(store)
    else
      if log then
        log:debug("Dispatching action to store:", effect, store:getState())
      end
      store:dispatch(effect)
    end
  end)()
end

function tablify(effects)
  if type(effects) == 'table' then
    return effects
  elseif type(effects) == 'nil' then
    return {}
  else
    return { effects }
  end
end
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.add(state, ...)
  local n = select('#', ...)
  local args = { n = n, ... }

  state = state or {}
  local _state = {}
  local added = {}
  local existing = state[module]

  if existing then
    for i, e in ipairs(tablify(existing)) do
      added[#added + 1] = e
    end
  end

  for i, e in ipairs(args) do
    added[#added + 1] = e
  end

  if #added > 0 then
    _state[module] = added
  end

  return imports.TableHelper.augment(_state, state)
end

function module.create(callback, name)
  local log = logger
  if log then
    log:verbose("Connecting RoduxEffects")
  end

  return function(nextDispatch, store)
    if log then
      log:verbose(
        "Attaching RoduxEffects to middleware")
    end

    return function(action)
      Assert(action, "Function parameter 'action' was not provided")

      if log then
        log:debug(
          "RoduxEffects middleware calling next dispatcher in chain", action)
      end

      local next = nextDispatch(action)
      local state = store:getState()

      if log then
        log:debug(
          "Executing RoduxEffects middleware", action, state)
      end

      for _, effect in ipairs(state[module] or {}) do
        dispatchEffect(store, effect)
      end

      return next
    end
  end
end

function module.withChildEffects(reducer)
  return function(state, action, ...)
    local _state = reducer(state, action, ...)

    if type(_state) == 'table' then
      local effects = {}

      for k, v in pairs(_state) do
        if type(v) == 'table' then
          local _effects = v[module]
          if _effects then
            if type(_effects) == 'table' then
              for _, e in ipairs(_effects) do
                effects[#effects + 1] = e
              end
            else
              effects[#effects + 1] = _effects
            end
            v[module] = nil
          end
        end
      end
      if #effects > 0 then
        _state[module] = effects
      end
    end

    return _state
  end
end

print "[LOAD] &lt;- shared/Helpers/RoduxEffects"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">RoduxRemoteBridge</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> shared/Helpers/RoduxRemoteBridge"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'RoduxRemoteBridge' })

local imports = {
  RemoteListener = Require.module('/shared/Helpers/RemoteListener'),
}

local function withDispatchActionFromClient(store)
  local log = logger

  return function(player, action)
    return coroutine.wrap(
      function()
        if log then
          log:debug("Dispatching action from client to store:", action)
        end

        store:dispatch(action)
      end)()
  end
end

local function withDispatchActionFromServer(store)
  local log = logger

  return function(action)
    return coroutine.wrap(
      function()
        if log then
          log:debug("Dispatching action from server to store:", action)
        end

        store:dispatch(action)
      end)()
  end
end

local function withDispatchActionToClient(event)
  local log = logger

  return function(action)
    return coroutine.wrap(
      function()
        if log then
          log:debug("Dispatching action to client:", action)
        end

        event:FireClient(action.player, action)
      end)()
  end
end

local function withDispatchActionToServer(event)
  local log = logger

  return function(action)
    return coroutine.wrap(
      function()
        if log then
          log:debug("Dispatching action to server:", action)
        end

        event:FireServer(action)
      end)()
  end
end
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = { }

function module.withDispatchFromRemote(store)
  return global.isClient and
    withDispatchActionFromServer(store) or
    withDispatchActionFromClient(store)
end

function module.withDispatchToRemote(event)
  return global.isClient and
    withDispatchActionToServer(event) or
    withDispatchActionToClient(event)
end

function module.relayDispatchesFromRemote(event, store)
  local listenerLabel =
    global.isClient and 'ServerReceiver' or 'ClientReceiver'

  return imports.RemoteListener:new(
    event, module.withDispatchFromRemote(store), listenerLabel):connect()
end

print "[LOAD] &lt;- shared/Helpers/RoduxRemoteBridge"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">TableHelper</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> shared/Helpers/Table"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'TableHelper' })
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.append(obj, ...)
  local n = select('#', ...)
  local arg = { n = n, ... }

  for i = 1, n do
    local member = arg[i]

    if member ~= nil then
      for _, v in ipairs(member or {}) do
        obj[#obj + 1] = v
      end
    end
  end

  return obj
end

function module.assign(obj, ...)
  local n = select('#', ...)
  local args = { n = n, ... }

  for _, arg in ipairs(args) do
    if arg ~= nil then
      for i, v in ipairs(arg) do
        obj[i] = v
      end
      for k, v in pairs(arg) do
        obj[k] = v
      end
    end
  end

  return obj
end

function module.augment(obj, ...)
  local n = select('#', ...)
  local args = { n = n, ... }

  for _, arg in ipairs(args) do
    if arg ~= nil then
      for i, v in ipairs(arg) do
        if obj[i] == nil then
          obj[i] = v
        end
      end
      for k, v in pairs(arg) do
        if obj[k] == nil then
          obj[k] = v
        end
      end
    end
  end

  return obj
end

function module.compose(...)
  local n = select('#', ...)
  local args = { n = n, ... }
  local currFn = nil

  for _, nextFn in ipairs(args) do
    if type(nextFn) == 'function' then
      currFn = currFn and (function(prev, next)
        return function(...)
          return next(prev(...))
        end
      end)(currFn, nextFn) or nextFn
    end
  end

  return currFn
end

print "[LOAD] &lt;- shared/Helpers/Table"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="18">
        <Properties>
          <string name="Name">Lib</string>
        </Properties>
        <Item class="ModuleScript" referent="19">
          <Properties>
            <string name="Name">Rodux</string>
            <string name="Source"><![CDATA[local Store = require(script.Store)
local createReducer = require(script.createReducer)
local combineReducers = require(script.combineReducers)
local makeActionCreator = require(script.makeActionCreator)
local loggerMiddleware = require(script.loggerMiddleware)
local thunkMiddleware = require(script.thunkMiddleware)

return {
	Store = Store,
	createReducer = createReducer,
	combineReducers = combineReducers,
	makeActionCreator = makeActionCreator,
	loggerMiddleware = loggerMiddleware.middleware,
	thunkMiddleware = thunkMiddleware,
}
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="20">
            <Properties>
              <string name="Name">NoYield</string>
              <string name="Source">--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co, ok, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "Attempted to yield inside changed event!"), 2)
	end

	return ...
end

local function NoYield(callback, ...)
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return NoYield</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="21">
            <Properties>
              <string name="Name">Signal</string>
              <string name="Source">--[[
	A limited, simple implementation of a Signal.

	Handlers are fired in order, and (dis)connections are properly handled when
	executing an event.
]]

local function immutableAppend(list, ...)
	local new = {}
	local len = #list

	for key = 1, len do
		new[key] = list[key]
	end

	for i = 1, select("#", ...) do
		new[len + i] = select(i, ...)
	end

	return new
end

local function immutableRemoveValue(list, removeValue)
	local new = {}

	for i = 1, #list do
		if list[i] ~= removeValue then
			table.insert(new, list[i])
		end
	end

	return new
end

local Signal = {}

Signal.__index = Signal

function Signal.new()
	local self = {
		_listeners = {}
	}

	setmetatable(self, Signal)

	return self
end

function Signal:connect(callback)
	local listener = {
		callback = callback,
		disconnected = false,
	}

	self._listeners = immutableAppend(self._listeners, listener)

	local function disconnect()
		listener.disconnected = true
		self._listeners = immutableRemoveValue(self._listeners, listener)
	end

	return {
		disconnect = disconnect
	}
end

function Signal:fire(...)
	for _, listener in ipairs(self._listeners) do
		if not listener.disconnected then
			listener.callback(...)
		end
	end
end

return Signal</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="22">
            <Properties>
              <string name="Name">Store</string>
              <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)
local NoYield = require(script.Parent.NoYield)

local Store = {}

-- This value is exposed as a private value so that the test code can stay in
-- sync with what event we listen to for dispatching the Changed event.
-- It may not be Heartbeat in the future.
Store._flushEvent = RunService.Heartbeat

Store.__index = Store

--[[
	Create a new Store whose state is transformed by the given reducer function.

	Each time an action is dispatched to the store, the new state of the store
	is given by:

		state = reducer(state, action)

	Reducers do not mutate the state object, so the original state is still
	valid.
]]
function Store.new(reducer, initialState, middlewares)
	assert(typeof(reducer) == "function", "Bad argument #1 to Store.new, expected function.")
	assert(middlewares == nil or typeof(middlewares) == "table", "Bad argument #3 to Store.new, expected nil or table.")

	local self = {}

	self._reducer = reducer
	self._state = reducer(initialState, {
		type = "@@INIT",
	})
	self._lastState = self._state

	self._mutatedSinceFlush = false
	self._connections = {}

	self.changed = Signal.new()

	setmetatable(self, Store)

	local connection = self._flushEvent:Connect(function()
		self:flush()
	end)
	table.insert(self._connections, connection)

	if middlewares then
		local unboundDispatch = self.dispatch
		local dispatch = function(...)
			return unboundDispatch(self, ...)
		end

		for i = #middlewares, 1, -1 do
			local middleware = middlewares[i]
			dispatch = middleware(dispatch, self)
		end

		self.dispatch = function(self, ...)
			return dispatch(...)
		end
	end

	return self
end

--[[
	Get the current state of the Store. Do not mutate this!
]]
function Store:getState()
	return self._state
end

--[[
	Dispatch an action to the store. This allows the store's reducer to mutate
	the state of the application by creating a new copy of the state.

	Listeners on the changed event of the store are notified when the state
	changes, but not necessarily on every Dispatch.
]]
function Store:dispatch(action)
	if typeof(action) == "table" then
		if action.type == nil then
			error("action does not have a type field", 2)
		end

		self._state = self._reducer(self._state, action)
		self._mutatedSinceFlush = true
	else
		error(("actions of type %q are not permitted"):format(typeof(action)), 2)
	end
end

--[[
	Marks the store as deleted, disconnecting any outstanding connections.
]]
function Store:destruct()
	for _, connection in ipairs(self._connections) do
		connection:Disconnect()
	end

	self._connections = nil
end

--[[
	Flush all pending actions since the last change event was dispatched.
]]
function Store:flush()
	if not self._mutatedSinceFlush then
		return
	end

	self._mutatedSinceFlush = false

	-- On self.changed:fire(), further actions may be immediately dispatched, in
	-- which case self._lastState will be set to the most recent self._state,
	-- unless we cache this value first
	local state = self._state

	-- If a changed listener yields, *very* surprising bugs can ensue.
	-- Because of that, changed listeners cannot yield.
	NoYield(function()
		self.changed:fire(state, self._lastState)
	end)

	self._lastState = state
end

return Store
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="23">
            <Properties>
              <string name="Name">combineReducers</string>
              <string name="Source"><![CDATA[--[[
	Create a composite reducer from a map of keys and sub-reducers.
]]
local function combineReducers(map)
	return function(state, action)
		-- If state is nil, substitute it with a blank table.
		if state == nil then
			state = {}
		end

		local newState = {}

		for key, reducer in pairs(map) do
			-- Each reducer gets its own state, not the entire state table
			newState[key] = reducer(state[key], action)
		end

		return newState
	end
end

return combineReducers
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="24">
            <Properties>
              <string name="Name">createReducer</string>
              <string name="Source"><![CDATA[return function(initialState, handlers)
	return function(state, action)
		if state == nil then
			state = initialState
		end

		local handler = handlers[action.type]

		if handler then
			return handler(state, action)
		end

		return state
	end
end
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="25">
            <Properties>
              <string name="Name">loggerMiddleware</string>
              <string name="Source"><![CDATA[local indent = "    "

local function prettyPrint(value, indentLevel)
	indentLevel = indentLevel or 0
	local output = {}

	if typeof(value) == "table" then
		table.insert(output, "{\n")

		for key, value in pairs(value) do
			table.insert(output, indent:rep(indentLevel + 1))
			table.insert(output, tostring(key))
			table.insert(output, " = ")

			table.insert(output, prettyPrint(value, indentLevel + 1))
			table.insert(output, "\n")
		end

		table.insert(output, indent:rep(indentLevel))
		table.insert(output, "}")
	elseif typeof(value) == "string" then
		table.insert(output, string.format("%q", value))
		table.insert(output, " (string)")
	else
		table.insert(output, tostring(value))
		table.insert(output, " (")
		table.insert(output, typeof(value))
		table.insert(output, ")")
	end

	return table.concat(output, "")
end

-- We want to be able to override outputFunction in tests, so the shape of this
-- module is kind of unconventional.
--
-- We fix it this weird shape in init.lua.
local loggerMiddleware = {
	outputFunction = print,
}

function loggerMiddleware.middleware(nextDispatch, store)
	return function(action)
		local result = nextDispatch(action)

		loggerMiddleware.outputFunction(("Action dispatched: %s\nState changed to: %s"):format(
			prettyPrint(action),
			prettyPrint(store:getState())
		))

		return result
	end
end

return loggerMiddleware
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="26">
            <Properties>
              <string name="Name">makeActionCreator</string>
              <string name="Source"><![CDATA[--[[
	A helper function to define a Rodux action creator with an associated name.
]]
local function makeActionCreator(name, fn)
	assert(type(name) == "string", "Bad argument #1: Expected a string name for the action creator")

	assert(type(fn) == "function", "Bad argument #2: Expected a function that creates action objects")

	return setmetatable({
		name = name,
	}, {
		__call = function(self, ...)
			local result = fn(...)

			assert(type(result) == "table", "Invalid action: An action creator must return a table")

			result.type = name

			return result
		end
	})
end

return makeActionCreator
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="27">
            <Properties>
              <string name="Name">thunkMiddleware</string>
              <string name="Source"><![CDATA[--[[
	A middleware that allows for functions to be dispatched.
	Functions will receive a single argument, the store itself.
	This middleware consumes the function; middleware further down the chain
	will not receive it.
]]
local function thunkMiddleware(nextDispatch, store)
	return function(action)
		if typeof(action) == "function" then
			return action(store)
		else
			return nextDispatch(action)
		end
	end
end

return thunkMiddleware
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="28">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="29">
      <Properties>
        <string name="Name">Assets</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="30">
      <Properties>
        <string name="Name">Scripts</string>
      </Properties>
      <Item class="ModuleScript" referent="31">
        <Properties>
          <string name="Name">Game</string>
          <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> server/Game/init"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'GameServer' })

local imports = {
  PlayerState = Require.module('/runEnv/Game/PlayerState'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.initRunEnv(initializeStoreFn)
  local log = logger
  if log then
    log:info("Starting game")
  end

  local store = coroutine.wrap(initializeStoreFn)()
  imports.PlayerState.listenForPlayerAdded(store)
end

print "[LOAD] &lt;- server/Game/init"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
        </Properties>
        <Item class="Script" referent="32">
          <Properties>
            <string name="Name">Bootstrap</string>
            <string name="Source">print "[LOAD] -> server/Game/Bootstrap.server"

require(
  game:GetService('ReplicatedStorage').Scripts.Game.Bootstrap
)({
  defaults = { logLevel = 'WARN', waitTimeout = 10 },
})

print "[LOAD] &lt;- server/Game/Bootstrap.server"</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="33">
          <Properties>
            <string name="Name">GameState</string>
          </Properties>
          <Item class="ModuleScript" referent="34">
            <Properties>
              <string name="Name">Reducer</string>
              <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> server/Game/GameState/Reducer"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'GameStateReducer' })

local imports = {
  PlayerStateReducer = Require.module('/server/Game/PlayerState/Reducer'),
  Reducer = Require.module('/shared/Helpers/Reducer'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local function getInitialState()
  return {
    PlayerState = imports.PlayerStateReducer.getInitialState(),
  }
end

function module.create(remoteDispatcher)
  local playerStateReducer = imports.Reducer.withMergedState(
    imports.PlayerStateReducer.create(remoteDispatcher))

  return function(state, action)
    return {
      PlayerState = playerStateReducer(state.PlayerState, action),
    }
  end
end

function module.getInitialState()
  return getInitialState()
end

print "[LOAD] &lt;- server/Game/GameState/Reducer"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="35">
            <Properties>
              <string name="Name">Store</string>
              <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> server/Game/GameState/Store"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'GameStateStore' })

local imports = {
  GameStateReducer = Require.module('/server/Game/GameState/Reducer'),
  Rodux = Require.module('/shared/Lib/Rodux'),
  RoduxEffects = Require.module('/shared/Helpers/RoduxEffects'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------

local module = {}

function module.create(remoteDispatcher)
  local reducer = imports.RoduxEffects.withChildEffects(
    imports.GameStateReducer.create(remoteDispatcher))

  local middleware = { imports.RoduxEffects.create() }

  return imports.Rodux.Store.new(
    reducer, imports.GameStateReducer.getInitialState(), middleware)
end

print "[LOAD] &lt;- server/Game/GameState/Store"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="36">
          <Properties>
            <string name="Name">PlayerState</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> server/Game/PlayerState/init"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'PlayerState' })

local imports = {
  PlayerStateActions = Require.module('/server/Game/PlayerState/Actions'),
  Players = Require.service('Players'),
}

local function addPlayers(callback)
  local Players = imports.Players

  for _, player in ipairs(Players:GetPlayers()) do
    callback(player)
  end
end

local function onPlayerRemovingFn(store)
  return function(player)
    coroutine.wrap(
      function()
        local log = logger
        if log then
          log:debug("Dispatching action for PlayerRemoving", player)
        end

        store:dispatch(imports.PlayerStateActions.playerRemoving(player))
      end
    )()
  end
end

local function onPlayerAddedFn(store)
  return function(player)
    coroutine.wrap(
      function()
        local log = logger
        if log then
          log:debug("Dispatching action for PlayerAdded", player)
        end

        imports.Players.PlayerRemoving:Connect(onPlayerRemovingFn(store))
        store:dispatch(imports.PlayerStateActions.playerAdded(player))
      end
    )()
  end
end
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.listenForPlayerAdded(store)
  local playerAddedFn = onPlayerAddedFn(store)
  imports.Players.PlayerAdded:Connect(playerAddedFn)
  addPlayers(playerAddedFn)
end

print "[LOAD] &lt;- server/Game/PlayerState/init"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
          <Item class="ModuleScript" referent="37">
            <Properties>
              <string name="Name">Actions</string>
              <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> server/Game/PlayerState/Actions"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local moduleName = 'PlayerStateActions'
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = moduleName })
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local typeBalanceAdjusted = moduleName .. ":" .. 'balanceAdjusted'
local typeBalanceUpdated = moduleName .. ":" .. 'balanceUpdated'
local typePlayerAdded = moduleName .. ":" .. 'playerAdded'
local typePlayerRemoving = moduleName .. ":" .. 'playerRemoving'
local typeWagerConcluded = moduleName .. ":" .. 'wagerConcluded'

module.ACTION_TYPE = {
  balanceAdjusted = typeBalanceAdjusted,
  balanceUpdated = typeBalanceUpdated,
  playerAdded = typePlayerAdded,
  playerRemoving = typePlayerRemoving,
  wagerConcluded = typeWagerConcluded,
}

function module.balanceAdjusted(player, adjustedAmount)
  return {
    type = typeBalanceAdjusted,
    player = player,
    adjustedAmount = adjustedAmount,
  }
end

function module.balanceUpdated(player, balance)
  return {
    type = typeBalanceUpdated,
    player = player,
    balance = balance,
  }
end

function module.playerAdded(player)
  return {
    type = typePlayerAdded,
    player = player,
  }
end

function module.playerRemoving(player)
  return {
    type = typePlayerRemoving,
    player = player,
  }
end

function module.wagerConcluded(player, wagerAmount, earnings)
  return {
    type = typeWagerConcluded,
    player = player,
    wagerAmount = wagerAmount,
    earnings = earnings,
  }
end

print "[LOAD] &lt;- server/Game/PlayerState/Actions"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="38">
            <Properties>
              <string name="Name">Reducer</string>
              <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> server/Game/PlayerState/Reducer"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'PlayerStateReducer' })

local imports = {
  PlayerStateActions = Require.module('/server/Game/PlayerState/Actions'),
  Reducer = Require.module('/shared/Helpers/Reducer'),
  RemoteActions = Require.module('/shared/Game/RemoteActions'),
  RoduxEffects = Require.module('/shared/Helpers/RoduxEffects'),
  TableHelper = Require.module('/shared/Helpers/TableHelper'),
  remoteDispatcher = nil, -- to be provided by the invoker of 'module.create'
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------

local module = {}

local function getInitialPlayerState()
  return {
    balance = 100,
  }
end

local function getInitialState()
  return {
    players = {},
  }
end

local function doWagerRequestedFn(player, wagerAmount)
  local actions = imports.PlayerStateActions

  return function(store)
    wait(math.random(1, 1))

    local state = store:getState().PlayerState
    local playerState = state.players[player]

    if (playerState) then
      local balance = playerState.balance
      local toWager = math.min(wagerAmount, balance)
      local earnings = math.random(-toWager, toWager)

      store:dispatch(actions.balanceAdjusted(player, earnings))
      store:dispatch(actions.wagerConcluded(player, wagerAmount, earnings))
    end
  end
end

local function onBalanceAdjusted(state, action)
  local assign = imports.TableHelper.assign
  local player = action.player
  local playerState = state.players[player]

  if playerState then
    local balance = playerState.balance + action.adjustedAmount

    playerState = assign({}, playerState, {
      balance = balance,
    })

    local players = assign({}, state.players)
    players[action.player] = playerState

    return imports.RoduxEffects.add(
      {
        players = players,
      },
      imports.remoteDispatcher(
        imports.RemoteActions.balanceUpdated(player, balance)))
  end
  return {}
end

local function onBalanceUpdated(state, action)
  local assign = imports.TableHelper.assign
  local player = action.player
  local playerState = state.players[action.player]

  if playerState then
    local balance = action.balance

    playerState = assign({}, playerState, {
      balance = balance,
    })

    local players = assign({}, state.players)
    players[action.player] = playerState

    return imports.RoduxEffects.add(
      {
        players = players,
      },
      imports.remoteDispatcher(
        imports.RemoteActions.balanceUpdated(player, balance)))
  end
  return {}
end

local function onPlayerAdded(state, action)
  local player = action.player
  local playerState = getInitialPlayerState()
  local players = imports.TableHelper.assign({}, state.players)
  players[player] = playerState

  return imports.RoduxEffects.add(
    {
      players = players,
    },
    imports.remoteDispatcher(
      imports.RemoteActions.balanceUpdated(player, playerState.balance)))
end

local function onPlayerRemoving(state, action)
  local players = imports.TableHelper.assign({}, state.players)
  players[action.player] = nil

  return {
    players = players,
  }
end

local function onWagerConcluded(state, action)
  return imports.RoduxEffects.add({},
    imports.remoteDispatcher(
      imports.RemoteActions.wagerConcluded(
        action.player, action.wagerAmount, action.earnings)))
end

local function onWagerRequested(state, action)
  return imports.RoduxEffects.add({},
    doWagerRequestedFn(action.player, action.wagerAmount))
end

function module.create(remoteDispatcher)
  local actionTypes = imports.PlayerStateActions.ACTION_TYPE
  local remoteActionTypes = imports.RemoteActions.ACTION_TYPE

  local handlers = {}
  handlers[actionTypes.balanceAdjusted] = onBalanceAdjusted
  handlers[actionTypes.balanceUpdated] = onBalanceUpdated
  handlers[actionTypes.playerAdded] = onPlayerAdded
  handlers[actionTypes.playerRemoving] = onPlayerRemoving
  handlers[actionTypes.wagerConcluded] = onWagerConcluded
  handlers[remoteActionTypes.wagerRequested] = onWagerRequested

  imports.remoteDispatcher = remoteDispatcher
  return imports.Reducer.create(getInitialState(), handlers)
end

function module.getInitialState()
  return getInitialState()
end

print "[LOAD] &lt;- server/Game/PlayerState/Reducer"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="39">
        <Properties>
          <string name="Name">Lib</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="SoundService" referent="40">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="41">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="42">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="43">
        <Properties>
          <string name="Name">Assets</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="44">
        <Properties>
          <string name="Name">Scripts</string>
        </Properties>
        <Item class="ModuleScript" referent="45">
          <Properties>
            <string name="Name">Game</string>
            <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/init"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'GameClient' })

local imports = {
  MainGui = Require.module('/runEnv/Game/Gui/Main'),
  Players = Require.service('Players'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.initRunEnv(initializeStoreFn)
  local log = logger
  if log then
    log:info("Starting game")
  end

  local store = coroutine.wrap(initializeStoreFn)()
  imports.MainGui.mount(store, imports.Players)
end

print "[LOAD] &lt;- client/Game/init"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
          </Properties>
          <Item class="LocalScript" referent="46">
            <Properties>
              <string name="Name">Bootstrap</string>
              <string name="Source">print "[LOAD] -> client/Game/Bootstrap.client"

require(
  game:GetService('ReplicatedStorage').Scripts.Game.Bootstrap
)({
  defaults = { logLevel = 'WARN', waitTimeout = 10 },
})

print "[LOAD] &lt;- client/Game/Bootstrap.client"</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="47">
            <Properties>
              <string name="Name">GameState</string>
            </Properties>
            <Item class="ModuleScript" referent="48">
              <Properties>
                <string name="Name">Reducer</string>
                <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/GameState/Reducer"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'GameStateReducer' })

local imports = {
  MainGuiReducer = Require.module('/client/Game/Gui/Main/Reducer'),
  PlayerStateReducer = Require.module('/client/Game/PlayerState/Reducer'),
  Reducer = Require.module('/shared/Helpers/Reducer'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local function getInitialState()
  return {
    PlayerState = imports.PlayerStateReducer.getInitialState(),
    MainGui = imports.MainGuiReducer.getInitialState(),
  }
end

function module.create(remoteDispatcher)
  local playerStateReducer = imports.Reducer.withMergedState(
    imports.PlayerStateReducer.create(remoteDispatcher))

  local mainGuiReducer = imports.Reducer.withMergedState(
    imports.MainGuiReducer.create())

  return function(state, action)
    return {
      PlayerState = playerStateReducer(state.PlayerState, action),
      MainGui = mainGuiReducer(
        state.MainGui, action, { balance = state.PlayerState.balance }),
    }
  end
end

function module.getInitialState()
  return getInitialState()
end

print "[LOAD] &lt;- client/Game/GameState/Reducer"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="49">
              <Properties>
                <string name="Name">Store</string>
                <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/GameState/Store"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'GameStateStore' })

local imports = {
  GameStateReducer = Require.module('/client/Game/GameState/Reducer'),
  Rodux = Require.module('/shared/Lib/Rodux'),
  RoduxEffects = Require.module('/shared/Helpers/RoduxEffects'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

function module.create(remoteDispatcher)
  local reducer = imports.RoduxEffects.withChildEffects(
    imports.GameStateReducer.create(remoteDispatcher))

  local middleware = { imports.RoduxEffects.create() }

  return imports.Rodux.Store.new(
    reducer, imports.GameStateReducer.getInitialState(), middleware)
end

print "[LOAD] &lt;- client/Game/GameState/Store"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="50">
            <Properties>
              <string name="Name">Gui</string>
            </Properties>
            <Item class="ModuleScript" referent="51">
              <Properties>
                <string name="Name">Main</string>
                <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/Gui/Main/init"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'MainGui' })

local imports = {
  MainGuiActions = Require.module('/client/Game/Gui/Main/Actions'),
  MainGuiComponent = Require.module('/client/Game/Gui/Main/Component'),
  Roact = Require.module('/client/Lib/Roact'),
  RoactRodux = Require.module('/client/Lib/RoactRodux'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local function getDispatcher()
  local actions = imports.MainGuiActions

  return function(dispatch)
    return {
      onClickInc = function()
        dispatch(actions.wagerIncreased())
      end,
      onClickDec = function()
        dispatch(actions.wagerDecreased())
      end,
      onClickWager = function(...)
        dispatch(actions.wagerRequested())
      end,
    }
  end
end

local function mapStateToProps(state, props, ...)
  return {
    isRemoting = state.MainGui.isRemoting,
    balance = state.PlayerState.balance,
    wagerAmount = state.MainGui.wagerAmount,
  }
end

local function connect(component)
  return imports.RoactRodux.connect(
    mapStateToProps, getDispatcher())(component)
end

local function create(store)
  local mainGuiComponent = imports.MainGuiComponent
  local Roact = imports.Roact
  local RoactRodux = imports.RoactRodux

  return Roact.createElement(
    RoactRodux.StoreProvider,
    { store = store },
    { MainGui = Roact.createElement(
      connect(mainGuiComponent.create())) })
end

function module.mount(store, Players)
  return imports.Roact.mount(create(store), Players.LocalPlayer.PlayerGui)
end

print "[LOAD] &lt;- client/Game/Gui/Main/init"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
              </Properties>
              <Item class="ModuleScript" referent="52">
                <Properties>
                  <string name="Name">Actions</string>
                  <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/Gui/Main/Actions"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local moduleName = 'MainGuiActions'
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'MainGuiActions' })
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local actionTypeWagerConcluded = moduleName .. ":" .. 'wagerConcluded'
local actionTypeWagerDecreased = moduleName .. ":" .. 'wagerDecreased'
local actionTypeWagerIncreased = moduleName .. ":" .. 'wagerIncreased'
local actionTypeWagerRequested = moduleName .. ":" .. 'wagerRequested'

module.ACTION_TYPE = {
  wagerConcluded = actionTypeWagerConcluded,
  wagerDecreased = actionTypeWagerDecreased,
  wagerIncreased = actionTypeWagerIncreased,
  wagerRequested = actionTypeWagerRequested,
}

function module.wagerConcluded()
  return {
    type = actionTypeWagerConcluded,
  }
end

function module.wagerDecreased(amount)
  return {
    type = actionTypeWagerDecreased,
    amount = amount,
  }
end

function module.wagerIncreased(amount)
  return {
    type = actionTypeWagerIncreased,
    amount = amount,
  }
end

function module.wagerRequested()
  return {
    type = actionTypeWagerRequested,
  }
end

print "[LOAD] &lt;- client/Game/Gui/Main/Actions"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="53">
                <Properties>
                  <string name="Name">Component</string>
                  <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/Gui/Main/Component"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'MainGuiComponent' })

local imports = {
  Roact = Require.module('/client/Lib/Roact'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local inactiveBgColor = Color3.new(0.75, 0.75, 0.75)
local inactiveTextColor = Color3.new(0.25, 0.25, 0.25)

function module.create()
  local Roact = imports.Roact

  return function(props)
    local balance = props.balance
    local wagerAmount = props.wagerAmount
    local isRemoting = props.isRemoting
    local onClickInc = props.onClickInc
    local onClickDec = props.onClickDec
    local onClickWager = props.onClickWager

    local isUiActive = balance ~= nil
    local isWagerable = isUiActive and not isRemoting

    local activeOnlyBgColor =
      not isUiActive and inactiveBgColor or nil
    local activeOnlyTextColor =
      not isUiActive and inactiveTextColor or nil
    local wagerableOnlyBgColor =
      not isWagerable and inactiveBgColor or nil
    local wagerableOnlyTextColor =
      not isWagerable and inactiveTextColor or nil

    return Roact.createElement('ScreenGui', {
      Name = 'MainGui',
    }, {
      btnInc = Roact.createElement('TextButton', {
        Text = "Increase",
        Size = UDim2.new(0, 100, 0, 50),
        Position = UDim2.new(0, 25, 0, 25),
        BackgroundColor3 = activeOnlyBgColor,
        TextColor3 = activeOnlyTextColor,
        Active = isUiActive,
        AutoButtonColor = isUiActive,

        [Roact.Event.Activated] = onClickInc,
      }),
      lblWager = Roact.createElement('TextLabel', {
        Text = "Wager Amount: " .. wagerAmount,
        Size = UDim2.new(0, 125, 0, 50),
        Position = UDim2.new(0, 150, 0, 25),
        BackgroundColor3 = activeOnlyBgColor,
        TextColor3 = activeOnlyTextColor,
      }),
      btnDec = Roact.createElement('TextButton', {
        Text = "Decrease",
        Size = UDim2.new(0, 100, 0, 50),
        Position = UDim2.new(0, 300, 0, 25),
        BackgroundColor3 = activeOnlyBgColor,
        TextColor3 = activeOnlyTextColor,
        Active = isUiActive,
        AutoButtonColor = isUiActive,

        [Roact.Event.Activated] = onClickDec,
      }),
      btnWager = Roact.createElement('TextButton', {
        Text = isRemoting and "Placing Wager..." or "Wager!",
        Size = UDim2.new(0, 100, 0, 50),
        Position = UDim2.new(0, 425, 0, 25),
        BackgroundColor3 = wagerableOnlyBgColor,
        TextColor3 = wagerableOnlyTextColor,
        Active = isWagerable,
        AutoButtonColor = isWagerable,

        [Roact.Event.Activated] = onClickWager,
      }),
      lblBalance = Roact.createElement('TextLabel', {
        Text = "Balance: " .. (balance ~= nil and balance or "..."),
        Size = UDim2.new(0, 100, 0, 50),
        Position = UDim2.new(0, 550, 0, 25),
        BackgroundColor3 = activeOnlyBgColor,
        TextColor3 = activeOnlyTextColor,
      }),
    })
  end
end

print "[LOAD] &lt;- client/Game/Gui/Main/Component"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="54">
                <Properties>
                  <string name="Name">Reducer</string>
                  <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/Gui/Main/Reducer"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'MainGuiReducer' })

local imports = {
  MainGuiActions = Require.module('/client/Game/Gui/Main/Actions'),
  PlayerStateActions = Require.module('/client/Game/PlayerState/Actions'),
  Reducer = Require.module('/shared/Helpers/Reducer'),
  RoduxEffects = Require.module('/shared/Helpers/RoduxEffects'),
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local minWager, maxWager, incWager = 5, 25, 1

local function getInitialState()
  return {
    isRemoting = false,
    wagerAmount = maxWager,
  }
end

local function getBoundWagerAmount(wagerAmount, balance)
  balance = balance or 0
  local toWager = wagerAmount
  toWager = math.max(toWager, minWager)
  toWager = math.min(toWager, balance, maxWager)
  toWager = math.max(0, toWager)
  return toWager
end

local function onWagerConcluded(state, action, props)
  return {
    isRemoting = false,
  }
end

local function onWagerDecreased(state, action, props)
  return {
    wagerAmount = getBoundWagerAmount(
      state.wagerAmount - incWager, props.balance),
  }
end

local function onWagerIncreased(state, action, props)
  return {
    wagerAmount = getBoundWagerAmount(
      state.wagerAmount + incWager, props.balance),
  }
end

local function onWagerRequested(state, action, props)
  local wagerRequested = imports.PlayerStateActions.wagerRequested
  local wagerAmount = getBoundWagerAmount(
    state.wagerAmount, props.balance)

  return imports.RoduxEffects.add(
    {
      isRemoting = true,
      wagerAmount = wagerAmount,
    },
    wagerRequested(wagerAmount))
end

function module.create(transformer)
  local actions = imports.MainGuiActions
  local handlers = {}
  handlers[actions.ACTION_TYPE.wagerConcluded] = onWagerConcluded
  handlers[actions.ACTION_TYPE.wagerDecreased] = onWagerDecreased
  handlers[actions.ACTION_TYPE.wagerIncreased] = onWagerIncreased
  handlers[actions.ACTION_TYPE.wagerRequested] = onWagerRequested

  -- return imports.Reducer.create(getInitialState(), handlers, transformer)
  return imports.Reducer.create(getInitialState(), handlers)
end

function module.getInitialState()
  return getInitialState()
end

print "[LOAD] &lt;- client/Game/Gui/Main/Reducer"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="55">
            <Properties>
              <string name="Name">PlayerState</string>
            </Properties>
            <Item class="ModuleScript" referent="56">
              <Properties>
                <string name="Name">Actions</string>
                <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/PlayerState/Actions"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local moduleName = 'PlayerStateActions'
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = moduleName })

local typeBalanceUpdated = moduleName .. ":" .. 'balanceUpdated'
local typeWagerRequested = moduleName .. ":" .. 'wagerRequested'
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

module.ACTION_TYPE = {
  balanceUpdated = typeBalanceUpdated,
  wagerRequested = typeWagerRequested,
}

function module.balanceUpdated(balance)
  return {
    type = typeBalanceUpdated,
    balance = balance,
  }
end

function module.wagerRequested(wagerAmount)
  return {
    type = typeWagerRequested,
    wagerAmount = wagerAmount,
  }
end

print "[LOAD] &lt;- client/Game/PlayerState/Actions"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="57">
              <Properties>
                <string name="Name">Reducer</string>
                <string name="Source">-- WRAPPER FUNCTION FOR REQUIRE [BEGIN] --------------------------------------
return function(global)
print "[LOAD] -> client/Game/PlayerState/Reducer"

-- PRIVATE DATA AND HELPER FUNCTIONS [BEGIN] ---------------------------------
local Assert = global.Assert
local Require = global.Require

local logger = Require.module('/shared/Helpers/Logger'):new(
  { level = 'WARN', warnLevel = 'DEBUG', name = 'PlayerStateReducer' })

local imports = {
  MainGuiActions = Require.module('/client/Game/Gui/Main/Actions'),
  PlayerStateActions = Require.module('/client/Game/PlayerState/Actions'),
  Players = Require.service('Players'),
  Reducer = Require.module('/shared/Helpers/Reducer'),
  RemoteActions = Require.module('/shared/Game/RemoteActions'),
  RoduxEffects = Require.module('/shared/Helpers/RoduxEffects'),
  remoteDispatcher = nil, -- to be provided by the invoker of 'module.create'
}
-- PRIVATE DATA AND HELPER FUNCTIONS [END] -----------------------------------

-- MODULE DEFINITION [BEGIN] -------------------------------------------------
local module = {}

local function getInitialState()
  return {
    balance = nil,
  }
end

local function onBalanceUpdated(state, action)
  return {
    balance = action.balance
  }
end

local function onWagerConcluded(state, action)
  return imports.RoduxEffects.add({},
    imports.MainGuiActions.wagerConcluded(action))
end

local function onWagerRequested(state, action)
  local Players = imports.Players

  return imports.RoduxEffects.add({},
    imports.remoteDispatcher(
      imports.RemoteActions.wagerRequested(
        Players.LocalPlayer, action.wagerAmount)))
end

function module.create(remoteDispatcher)
  local actionTypes = imports.PlayerStateActions.ACTION_TYPE
  local remoteTypes = imports.RemoteActions.ACTION_TYPE

  local handlers = {}
  handlers[actionTypes.wagerRequested] = onWagerRequested
  handlers[remoteTypes.balanceUpdated] = onBalanceUpdated
  handlers[remoteTypes.wagerConcluded] = onWagerConcluded

  imports.remoteDispatcher = remoteDispatcher
  return imports.Reducer.create(getInitialState(), handlers)
end

function module.getInitialState()
  return getInitialState()
end

print "[LOAD] &lt;- client/Game/PlayerState/Reducer"
return module
-- MODULE DEFINITION [END] ---------------------------------------------------
end
-- WRAPPER FUNCTION FOR REQUIRE [END] ----------------------------------------</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="58">
          <Properties>
            <string name="Name">Lib</string>
          </Properties>
          <Item class="ModuleScript" referent="59">
            <Properties>
              <string name="Name">Roact</string>
              <string name="Source">--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict {
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,
	createContext = require(script.createContext),

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {
	},
}

return Roact</string>
            </Properties>
            <Item class="ModuleScript" referent="60">
              <Properties>
                <string name="Name">Binding</string>
                <string name="Source">local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = (
					"Expected arg #1 to contain only bindings, but key %q had a non-binding value"
				):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="61">
              <Properties>
                <string name="Name">Component</string>
                <string name="Source">local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate or
		lifecyclePhase == ComponentLifecyclePhase.WillUpdate or
		lifecyclePhase == ComponentLifecyclePhase.Render or
		lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.DidMount or
		lifecyclePhase == ComponentLifecyclePhase.DidUpdate or
		lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)

	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(
		tostring(internalData.componentClass)
	)

	error(message, 0)
end

--[[
	Retrieves the context value corresponding to the given key. Can return nil
	if a requested context key is not present
]]
function Component:__getContext(key)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getContext`")
		internalAssert(key ~= nil, "Context key cannot be nil")
	end

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

--[[
	Adds a new context entry to this component's context table (which will be
	passed down to child components).
]]
function Component:__addContext(key, value)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__addContext`")
	end
	local virtualNode = self[InternalData].virtualNode

	-- Make sure we store a reference to the component's original, unmodified
	-- context the virtual node. In the reconciler, we'll restore the original
	-- context if we need to replace the node (this happens when a node gets
	-- re-rendered as a different component)
	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	-- Build a new context table on top of the existing one, then apply it to
	-- our virtualNode
	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
			typeof(validator),
			self.__componentName
		))
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "&lt;Validator function did not supply a message>"
		error(("Property validation failed in %s: %s\n\n%s"):format(
			self.__componentName,
			tostring(failureReason),
			self:getElementTraceback() or "&lt;enable element tracebacks>"),
		0)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="62">
              <Properties>
                <string name="Name">ComponentLifecyclePhase</string>
                <string name="Source">local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="63">
              <Properties>
                <string name="Name">Config</string>
                <string name="Source">--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = (
				"Invalid global configuration key %q. Valid configuration keys are: %s"
			):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="64">
              <Properties>
                <string name="Name">ElementKind</string>
                <string name="Source">--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="65">
              <Properties>
                <string name="Name">ElementUtils</string>
                <string name="Source">local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="66">
              <Properties>
                <string name="Name">GlobalConfig</string>
                <string name="Source">--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="67">
              <Properties>
                <string name="Name">Logging</string>
                <string name="Source">--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = {"LogInfo {"}

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="68">
              <Properties>
                <string name="Name">None</string>
                <string name="Source">local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="69">
              <Properties>
                <string name="Name">NoopRenderer</string>
                <string name="Source">--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(reconciler, node)
end

function NoopRenderer.unmountHostNode(reconciler, node)
end

function NoopRenderer.updateHostNode(reconciler, node, newElement)
	return node
end

return NoopRenderer</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="70">
              <Properties>
                <string name="Name">Portal</string>
                <string name="Source">local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="71">
              <Properties>
                <string name="Name">PropMarkers</string>
              </Properties>
              <Item class="ModuleScript" referent="72">
                <Properties>
                  <string name="Name">Change</string>
                  <string name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="73">
                <Properties>
                  <string name="Name">Children</string>
                  <string name="Source">local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="74">
                <Properties>
                  <string name="Name">Event</string>
                  <string name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="75">
                <Properties>
                  <string name="Name">Ref</string>
                  <string name="Source">local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="76">
              <Properties>
                <string name="Name">PureComponent</string>
                <string name="Source">--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="77">
              <Properties>
                <string name="Name">RobloxRenderer</string>
                <string name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(
			typeof(ref)
		))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="78">
              <Properties>
                <string name="Name">SingleEventManager</string>
                <string name="Source">--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(
			tostring(key),
			event
		), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index &lt;= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="79">
              <Properties>
                <string name="Name">Symbol</string>
                <string name="Source">--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="80">
              <Properties>
                <string name="Name">Type</string>
                <string name="Source">--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="81">
              <Properties>
                <string name="Name">assertDeepEqual</string>
                <string name="Source">--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(
			typeof(a),
			typeof(b)
		)
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate
			:gsub("{1}", "first")
			:gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="82">
              <Properties>
                <string name="Name">assign</string>
                <string name="Source">local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="83">
              <Properties>
                <string name="Name">createContext</string>
                <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local createFragment = require(script.Parent.createFragment)
local createSignal = require(script.Parent.createSignal)
local Children = require(script.Parent.PropMarkers.Children)
local Component = require(script.Parent.Component)

--[[
	Construct the value that is assigned to Roact's context storage.
]]
local function createContextEntry(currentValue)
	return {
		value = currentValue,
		onUpdate = createSignal(),
	}
end

local function createProvider(context)
	local Provider = Component:extend("Provider")

	function Provider:init(props)
		self.contextEntry = createContextEntry(props.value)
		self:__addContext(context.key, self.contextEntry)
	end

	function Provider:willUpdate(nextProps)
		-- If the provided value changed, immediately update the context entry.
		--
		-- During this update, any components that are reachable will receive
		-- this updated value at the same time as any props and state updates
		-- that are being applied.
		if nextProps.value ~= self.props.value then
			self.contextEntry.value = nextProps.value
		end
	end

	function Provider:didUpdate(prevProps)
		-- If the provided value changed, after we've updated every reachable
		-- component, fire a signal to update the rest.
		--
		-- This signal will notify all context consumers. It's expected that
		-- they will compare the last context value they updated with and only
		-- trigger an update on themselves if this value is different.
		--
		-- This codepath will generally only update consumer components that has
		-- a component implementing shouldUpdate between them and the provider.
		if prevProps.value ~= self.props.value then
			self.contextEntry.onUpdate:fire(self.props.value)
		end
	end

	function Provider:render()
		return createFragment(self.props[Children])
	end

	return Provider
end

local function createConsumer(context)
	local Consumer = Component:extend("Consumer")

	function Consumer.validateProps(props)
		if type(props.render) ~= "function" then
			return false, "Consumer expects a `render` function"
		else
			return true
		end
	end

	function Consumer:init(props)
		-- This value may be nil, which indicates that our consumer is not a
		-- descendant of a provider for this context item.
		self.contextEntry = self:__getContext(context.key)
	end

	function Consumer:render()
		-- Render using the latest available for this context item.
		--
		-- We don't store this value in state in order to have more fine-grained
		-- control over our update behavior.
		local value
		if self.contextEntry ~= nil then
			value = self.contextEntry.value
		else
			value = context.defaultValue
		end

		return self.props.render(value)
	end

	function Consumer:didUpdate()
		-- Store the value that we most recently updated with.
		--
		-- This value is compared in the contextEntry onUpdate hook below.
		if self.contextEntry ~= nil then
			self.lastValue = self.contextEntry.value
		end
	end

	function Consumer:didMount()
		if self.contextEntry ~= nil then
			-- When onUpdate is fired, a new value has been made available in
			-- this context entry, but we may have already updated in the same
			-- update cycle.
			--
			-- To avoid sending a redundant update, we compare the new value
			-- with the last value that we updated with (set in didUpdate) and
			-- only update if they differ. This may happen when an update from a
			-- provider was blocked by an intermediate component that returned
			-- false from shouldUpdate.
			self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)
				if newValue ~= self.lastValue then
					-- Trigger a dummy state update.
					self:setState({})
				end
			end)
		end
	end

	function Consumer:willUnmount()
		if self.disconnect ~= nil then
			self.disconnect()
		end
	end

	return Consumer
end

local Context = {}
Context.__index = Context

function Context.new(defaultValue)
	return setmetatable({
		defaultValue = defaultValue,
		key = Symbol.named("ContextKey"),
	}, Context)
end

function Context:__tostring()
	return "RoactContext"
end

local function createContext(defaultValue)
	local context = Context.new(defaultValue)

	return {
		Provider = createProvider(context),
		Consumer = createConsumer(context),
	}
end

return createContext
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="84">
              <Properties>
                <string name="Name">createElement</string>
                <string name="Source">local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="85">
              <Properties>
                <string name="Name">createFragment</string>
                <string name="Source">local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="86">
              <Properties>
                <string name="Name">createReconciler</string>
                <string name="Source"><![CDATA[local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and legacyContext from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth

		-- If the node that is being replaced has modified context, we need to
		-- use the original *unmodified* context for the new node
		-- The `originalContext` field will be nil if the context was unchanged
		local context = virtualNode.originalContext or virtualNode.context
		local parentLegacyContext = virtualNode.parentLegacyContext

		unmountVirtualNode(virtualNode)
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(
					newElement,
					hostParent,
					concreteKey,
					virtualNode.context,
					virtualNode.legacyContext
				)

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element
			or renderResult == nil
			or typeof(renderResult) == "boolean"
		then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(("%s\n%s"):format(
				"Component returned invalid children:",
				virtualNode.currentElement.source or "<enable element tracebacks>"
			), 0)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local kind = ElementKind.of(virtualNode.currentElement)

		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,

			-- Legacy Context API
			-- A table of context values inherited from the parent node
			legacyContext = legacyContext,

			-- A saved copy of the parent context, used when replacing a node
			parentLegacyContext = legacyContext,

			-- Context API
			-- A table of context values inherited from the parent node
			context = context or {},

			-- A saved copy of the unmodified context; this will be updated when
			-- a component adds new context and used when a node is replaced
			originalContext = nil,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="87">
              <Properties>
                <string name="Name">createReconcilerCompat</string>
                <string name="Source">--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="88">
              <Properties>
                <string name="Name">createRef</string>
                <string name="Source">--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="89">
              <Properties>
                <string name="Name">createSignal</string>
                <string name="Source">--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="90">
              <Properties>
                <string name="Name">createSpy</string>
                <string name="Source">--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="91">
              <Properties>
                <string name="Name">getDefaultInstanceProperty</string>
                <string name="Source">--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="92">
              <Properties>
                <string name="Name">internalAssert</string>
                <string name="Source">local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="93">
              <Properties>
                <string name="Name">invalidSetStateMessages</string>
                <string name="Source">--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="94">
              <Properties>
                <string name="Name">oneChild</string>
                <string name="Source">--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="95">
              <Properties>
                <string name="Name">strict</string>
                <string name="Source">local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,

		__newindex = function(self, key, value)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,
	})
end

return strict</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="96">
            <Properties>
              <string name="Name">RoactRodux</string>
              <string name="Source">local StoreProvider = require(script.StoreProvider)
local connect = require(script.connect)
local getStore = require(script.getStore)
local TempConfig = require(script.TempConfig)

return {
	StoreProvider = StoreProvider,
	connect = connect,
	UNSTABLE_getStore = getStore,
	UNSTABLE_connect2 = connect,

	TEMP_CONFIG = TempConfig,
}</string>
            </Properties>
            <Item class="ModuleScript" referent="97">
              <Properties>
                <string name="Name">StoreProvider</string>
                <string name="Source">local Roact = require(script.Parent.Parent.Roact)

local storeKey = require(script.Parent.storeKey)

local StoreProvider = Roact.Component:extend("StoreProvider")

function StoreProvider:init(props)
	local store = props.store

	if store == nil then
		error("Error initializing StoreProvider. Expected a `store` prop to be a Rodux store.")
	end

	self._context[storeKey] = store
end

function StoreProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return StoreProvider</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="98">
              <Properties>
                <string name="Name">StoreProvider.spec</string>
                <string name="Source">return function()
	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	it("should be instantiable as a component", function()
		local store = Rodux.Store.new(function()
			return 0
		end)
		local element = Roact.createElement(StoreProvider, {
			store = store
		})

		expect(element).to.be.ok()

		local handle = Roact.mount(element, nil, "StoreProvider-test")

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should expect a 'store' prop", function()
		local element = Roact.createElement(StoreProvider)

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="99">
              <Properties>
                <string name="Name">Symbol</string>
                <string name="Source">--[[
	A 'Symbol' is an opaque marker type that can be used to signify unique
	statuses. Symbols have the type 'userdata', but when printed to the console,
	the name of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[[
	Create an unnamed Symbol. Usually, you should create a named Symbol using
	Symbol.named(name)
]]
function Symbol.unnamed()
	local self = newproxy(true)

	getmetatable(self).__tostring = function()
		return "Unnamed Symbol"
	end

	return self
end

return Symbol</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="100">
              <Properties>
                <string name="Name">Symbol.spec</string>
                <string name="Source">return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)

	describe("unnamed", function()
		it("should give an opaque object", function()
			local symbol = Symbol.unnamed()

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to some string", function()
			local symbol = Symbol.unnamed()

			expect(tostring(symbol)).to.be.a("string")
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.unnamed()
			local symbolB = Symbol.unnamed()

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="101">
              <Properties>
                <string name="Name">TempConfig</string>
                <string name="Source"><![CDATA[return {
	newConnectionOrder = true,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="102">
              <Properties>
                <string name="Name">connect</string>
                <string name="Source">local Roact = require(script.Parent.Parent.Roact)
local getStore = require(script.Parent.getStore)
local shallowEqual = require(script.Parent.shallowEqual)
local join = require(script.Parent.join)

local TempConfig = require(script.Parent.TempConfig)

--[[
	Formats a multi-line message with printf-style placeholders.
]]
local function formatMessage(lines, parameters)
	return table.concat(lines, "\n"):format(unpack(parameters or {}))
end

local function noop()
	return nil
end

--[[
	The stateUpdater accepts props when they update and computes the
	complete set of props that should be passed to the wrapped component.

	Each connected component will have a stateUpdater created for it.

	stateUpdater is put into the component's state in order for
	getDerivedStateFromProps to be able to access it. It is not mutated.
]]
local function makeStateUpdater(store)
	return function(nextProps, prevState, mappedStoreState)
		-- The caller can optionally provide mappedStoreState if it needed that
		-- value beforehand. Doing so is purely an optimization.
		if mappedStoreState == nil then
			mappedStoreState = prevState.mapStateToProps(store:getState(), nextProps)
		end

		local propsForChild = join(nextProps, mappedStoreState, prevState.mappedStoreDispatch)

		return {
			mappedStoreState = mappedStoreState,
			propsForChild = propsForChild,
		}
	end
end

--[[
	mapStateToProps:
		(storeState, props) -> partialProps
		OR
		() -> (storeState, props) -> partialProps
	mapDispatchToProps: (dispatch) -> partialProps
]]
local function connect(mapStateToPropsOrThunk, mapDispatchToProps)
	local connectTrace = debug.traceback()

	if mapStateToPropsOrThunk ~= nil then
		assert(typeof(mapStateToPropsOrThunk) == "function", "mapStateToProps must be a function or nil!")
	else
		mapStateToPropsOrThunk = noop
	end

	if mapDispatchToProps ~= nil then
		assert(typeof(mapDispatchToProps) == "function", "mapDispatchToProps must be a function or nil!")
	else
		mapDispatchToProps = noop
	end

	return function(innerComponent)
		if innerComponent == nil then
			local message = formatMessage({
				"connect returns a function that must be passed a component.",
				"Check the connection at:",
				"%s",
			}, {
				connectTrace,
			})

			error(message, 2)
		end

		local componentName = ("RoduxConnection(%s)"):format(tostring(innerComponent))

		local Connection = Roact.Component:extend(componentName)

		function Connection.getDerivedStateFromProps(nextProps, prevState)
			if prevState.stateUpdater ~= nil then
				return prevState.stateUpdater(nextProps, prevState)
			end
		end

		function Connection:createStoreConnection()
			self.storeChangedConnection = self.store.changed:connect(function(storeState)
				self:setState(function(prevState, props)
					local mappedStoreState = prevState.mapStateToProps(storeState, props)

					-- We run this check here so that we only check shallow
					-- equality with the result of mapStateToProps, and not the
					-- other props that could be passed through the connector.
					if shallowEqual(mappedStoreState, prevState.mappedStoreState) then
						return nil
					end

					return prevState.stateUpdater(props, prevState, mappedStoreState)
				end)
			end)
		end

		function Connection:init()
			self.store = getStore(self)

			if self.store == nil then
				local message = formatMessage({
					"Cannot initialize Roact-Rodux connection without being a descendent of StoreProvider!",
					"Tried to wrap component %q",
					"Make sure there is a StoreProvider above this component in the tree.",
				}, {
					tostring(innerComponent),
				})

				error(message)
			end

			local storeState = self.store:getState()

			local mapStateToProps = mapStateToPropsOrThunk
			local mappedStoreState = mapStateToProps(storeState, self.props)

			-- mapStateToPropsOrThunk can return a function instead of a state
			-- value. In this variant, we keep that value as mapStateToProps
			-- instead of the original mapStateToProps. This matches react-redux
			-- and enables connectors to keep instance-level state.
			if typeof(mappedStoreState) == "function" then
				mapStateToProps = mappedStoreState
				mappedStoreState = mapStateToProps(storeState, self.props)
			end

			if mappedStoreState ~= nil and typeof(mappedStoreState) ~= "table" then
				local message = formatMessage({
					"mapStateToProps must either return a table, or return another function that returns a table.",
					"Instead, it returned %q, which is of type %s.",
				}, {
					tostring(mappedStoreState),
					typeof(mappedStoreState),
				})

				error(message)
			end

			local mappedStoreDispatch = mapDispatchToProps(function(...)
				return self.store:dispatch(...)
			end)

			local stateUpdater = makeStateUpdater(self.store)

			self.state = {
				-- Combines props, mappedStoreDispatch, and the result of
				-- mapStateToProps into propsForChild. Stored in state so that
				-- getDerivedStateFromProps can access it.
				stateUpdater = stateUpdater,

				-- Used by the store changed connection and stateUpdater to
				-- construct propsForChild.
				mapStateToProps = mapStateToProps,

				-- Used by stateUpdater to construct propsForChild.
				mappedStoreDispatch = mappedStoreDispatch,

				-- Passed directly into the component that Connection is
				-- wrapping.
				propsForChild = nil,
			}

			local extraState = stateUpdater(self.props, self.state, mappedStoreState)

			for key, value in pairs(extraState) do
				self.state[key] = value
			end

			if TempConfig.newConnectionOrder then
				self:createStoreConnection()
			end
		end

		function Connection:didMount()
			if not TempConfig.newConnectionOrder then
				self:createStoreConnection()
			end
		end

		function Connection:willUnmount()
			self.storeChangedConnection:disconnect()
		end

		function Connection:render()
			return Roact.createElement(innerComponent, self.state.propsForChild)
		end

		return Connection
	end
end

return connect</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="103">
              <Properties>
                <string name="Name">connect.spec</string>
                <string name="Source">return function()
	local connect = require(script.Parent.connect)

	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local TempConfig = require(script.Parent.TempConfig)

	local function noop()
		return nil
	end

	local function NoopComponent()
		return nil
	end

	local function countReducer(state, action)
		state = state or 0

		if action.type == "increment" then
			return state + 1
		end

		return state
	end

	local reducer = Rodux.combineReducers({
		count = countReducer,
	})

	describe("Argument validation", function()
		it("should accept no arguments", function()
			connect()
		end)

		it("should accept one function", function()
			connect(noop)
		end)

		it("should accept two functions", function()
			connect(noop, noop)
		end)

		it("should accept only the second function", function()
			connect(nil, function() end)
		end)

		it("should throw if not passed a component", function()
			local selector = function(store)
				return {}
			end

			expect(function()
				connect(selector)(nil)
			end).to.throw()
		end)
	end)

	it("should throw if not mounted under a StoreProvider", function()
		local ConnectedSomeComponent = connect()(NoopComponent)

		expect(function()
			Roact.mount(Roact.createElement(ConnectedSomeComponent))
		end).to.throw()
	end)

	it("should accept a higher-order function mapStateToProps", function()
		local function mapStateToProps()
			return function(state)
				return {
					count = state.count,
				}
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		Roact.unmount(handle)
	end)

	it("should not accept a higher-order mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return function(state)
				return "nope"
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should not accept a mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return "nah"
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should abort renders when mapStateToProps returns the same data", function()
		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(renderCount).to.equal(2)

		Roact.unmount(handle)
	end)

	it("should only call mapDispatchToProps once and never re-render if no mapStateToProps was passed", function()
		local dispatchCount = 0
		local mapDispatchToProps = function(dispatch)
			dispatchCount = dispatchCount + 1

			return {
				increment = function()
					return dispatch({ type = "increment" })
				end,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		Roact.unmount(handle)
	end)

	it("should return result values from the dispatch passed to mapDispatchToProps", function()
		local function reducer()
			return 0
		end

		local function fiveThunk()
			return 5
		end

		local dispatch
		local function SomeComponent(props)
			dispatch = props.dispatch
		end

		local function mapDispatchToProps(dispatch)
			return {
				dispatch = dispatch
			}
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		-- We'll use the thunk middleware, as it should always return its result
		local store = Rodux.Store.new(reducer, nil, { Rodux.thunkMiddleware })
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent)
		})

		local handle = Roact.mount(tree)

		expect(dispatch).to.be.a("function")
		expect(dispatch(fiveThunk)).to.equal(5)

		Roact.unmount(handle)
	end)

	it("should render parent elements before children", function()
		local oldNewConnectionOrder = TempConfig.newConnectionOrder
		TempConfig.newConnectionOrder = true

		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local childWasRenderedFirst = false

		local function ChildComponent(props)
			if props.count > props.parentCount then
				childWasRenderedFirst = true
			end
		end

		local ConnectedChildComponent = connect(mapStateToProps)(ChildComponent)

		local function ParentComponent(props)
			return Roact.createElement(ConnectedChildComponent, {
				parentCount = props.count,
			})
		end

		local ConnectedParentComponent = connect(mapStateToProps)(ParentComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			parent = Roact.createElement(ConnectedParentComponent),
		})

		local handle = Roact.mount(tree)

		store:dispatch({ type = "increment" })
		store:flush()

		store:dispatch({ type = "increment" })
		store:flush()

		Roact.unmount(handle)

		expect(childWasRenderedFirst).to.equal(false)

		TempConfig.newConnectionOrder = oldNewConnectionOrder
	end)

	it("should render child elements before children when TempConfig.newConnectionOrder is false", function()
		local oldNewConnectionOrder = TempConfig.newConnectionOrder
		TempConfig.newConnectionOrder = false

		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local childWasRenderedFirst = false

		local function ChildComponent(props)
			if props.count > props.parentCount then
				childWasRenderedFirst = true
			end
		end

		local ConnectedChildComponent = connect(mapStateToProps)(ChildComponent)

		local function ParentComponent(props)
			return Roact.createElement(ConnectedChildComponent, {
				parentCount = props.count,
			})
		end

		local ConnectedParentComponent = connect(mapStateToProps)(ParentComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			parent = Roact.createElement(ConnectedParentComponent),
		})

		local handle = Roact.mount(tree)

		store:dispatch({ type = "increment" })
		store:flush()

		store:dispatch({ type = "increment" })
		store:flush()

		Roact.unmount(handle)

		expect(childWasRenderedFirst).to.equal(true)

		TempConfig.newConnectionOrder = oldNewConnectionOrder
	end)
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="104">
              <Properties>
                <string name="Name">getStore</string>
                <string name="Source">local storeKey = require(script.Parent.storeKey)

local function getStore(componentInstance)
	return componentInstance._context[storeKey]
end

return getStore</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="105">
              <Properties>
                <string name="Name">getStore.spec</string>
                <string name="Source">return function()
	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local StoreProvider = require(script.Parent.StoreProvider)

	local getStore = require(script.Parent.getStore)

	it("should return the store when present", function()
		local function reducer()
			return 0
		end

		local store = Rodux.Store.new(reducer)
		local consumedStore = nil

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			Consumer = Roact.createElement(StoreConsumer),
		})

		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(store)

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should return nil when the store is not present", function()
		-- Use a non-nil value to know for sure if StoreConsumer:init was called
		local consumedStore = 6

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreConsumer)
		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(nil)

		Roact.unmount(handle)
	end)
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="106">
              <Properties>
                <string name="Name">join</string>
                <string name="Source">local function join(...)
	local result = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				result[key] = value
			end
		end
	end

	return result
end

return join</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="107">
              <Properties>
                <string name="Name">shallowEqual</string>
                <string name="Source">local function shallowEqual(a, b)
	if a == nil then
		return b == nil
	elseif b == nil then
		return a == nil
	end

	for key, value in pairs(a) do
		if value ~= b[key] then
			return false
		end
	end

	for key, value in pairs(b) do
		if value ~= a[key] then
			return false
		end
	end

	return true
end

return shallowEqual</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="108">
              <Properties>
                <string name="Name">shallowEqual.spec</string>
                <string name="Source">return function()
	local shallowEqual = require(script.Parent.shallowEqual)

	it("should compare dictionaries", function()
		local a = {
			a = "a",
			b = {},
			c = 6,
		}

		local b = {
			b = a.b,
			c = a.c,
			a = a.a,
		}

		local c = {
			b = {},
			a = a.a,
			c = a.c,
		}

		local d = {
			a = a.a,
			b = a.b,
			c = a.c,
			d = "hello",
		}

		expect(shallowEqual(a, a)).to.equal(true)
		expect(shallowEqual(a, b)).to.equal(true)
		expect(shallowEqual(a, c)).to.equal(false)
		expect(shallowEqual(b, c)).to.equal(false)
		expect(shallowEqual(a, d)).to.equal(false)
		expect(shallowEqual(b, d)).to.equal(false)
	end)

	it("should handle nil for either argument", function()
		local a = {}

		expect(shallowEqual(nil, nil)).to.equal(true)
		expect(shallowEqual(a, nil)).to.equal(false)
		expect(shallowEqual(nil, a)).to.equal(false)
	end)
end</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="109">
              <Properties>
                <string name="Name">storeKey</string>
                <string name="Source">local Symbol = require(script.Parent.Symbol)

return Symbol.named("RoduxStore")</string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="110">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
    </Properties>
    <Item class="Part" referent="111">
      <Properties>
        <string name="Name">Baseplate</string>
        <bool name="Anchored">true</bool>
        <Color3uint8 name="Color3uint8">6446690</Color3uint8>
        <bool name="Locked">true</bool>
        <Vector3 name="Position">
          <X>0</X>
          <Y>-10</Y>
          <Z>0</Z>
        </Vector3>
        <Vector3 name="size">
          <X>512</X>
          <Y>20</Y>
          <Z>512</Z>
        </Vector3>
      </Properties>
    </Item>
  </Item>
</roblox>